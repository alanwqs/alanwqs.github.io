(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{198:function(t,e,_){"use strict";_.r(e);var r=_(0),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),_("p",[t._v("(3) 系统内核参数设置：")]),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),_("p",[t._v("http1.1在使用长连接的情况下，建立一个连接通道后，连接上消息的传递类似于")]),t._v(" "),t._m(32),t._v(" "),_("p",[t._v("管道化连接的消息就变成了类似这样")]),t._v(" "),t._m(33),t._v(" "),_("p",[t._v("管线化是在同一个TCP连接里发一个请求后不必等其回来就可以继续发请求出去，这可以减少整体的响应时间，但是服务器还是会按照请求的顺序响应请求，所以如果有许多请求，而前面的请求响应很慢，就产生一个著名的问题队头堵塞")]),t._v(" "),t._m(34),t._v(" "),t._m(35),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),_("p",[t._v("因为一个域名允许分配多个长连接，就相当于增加了任务队列，不至于一个队列里的任务阻塞了其他全部任务。以前在RFC2616中规定过客户端最多只能并发2个连接，但是现实是很多浏览器不按套路出牌，所以在RFC7230把这个规定取消掉了，现在的浏览器标准中一个域名并发连接可以有6~8个，记住是6~8个，不是6个(Chrome6个/Firefox8个)")]),t._v(" "),t._m(39),t._v(" "),_("p",[t._v("一个域名最多可以并发6~8个，那咱就多来几个域名")]),t._v(" "),_("p",[t._v("比如a.baidu.com，b.baidu.com，c.baidu.com，多准备几个二级域名，当我们访问baidu.com时，可以让不同的资源从不同的二域名中获取，而它们都指向同一台服务器，这样能够并发更多的长连接了")]),t._v(" "),_("p",[t._v("而在HTTP2.0下，可以一瞬间加载出来很多资源，因为支持多路复用，可以在一个TCP连接中发送多个请求")]),t._v(" "),t._m(40),t._v(" "),t._m(41),t._v(" "),t._m(42),t._v(" "),_("p",[t._v("如图：代理服务器相当于一个中间人，一直帮两边传递东西，好可怜~~")]),t._v(" "),_("p",[t._v("不过它可以在中间可以帮我们过滤、缓存、负载均衡(多台服务器共用一台代理情况下)等一些处理")]),t._v(" "),_("p",[t._v("注意，实际场景中客户端和服务器之间可能有多个代理服务器")]),t._v(" "),t._m(43),t._v(" "),_("p",[t._v("客户端通过CONNECT方法请求隧道代理创建一个可以到任意目标服务器和端口号的TCP连接，创建成功之后隧道代理只做请求和响应数据的转发，中间它不会做任何处理")]),t._v(" "),t._m(44),t._v(" "),_("p",[t._v("为什么需要隧道代理呢？")]),t._v(" "),_("p",[t._v("我们都知道https服务是需要网站有证书的，而代理服务器显然没有，所以浏览器和代理之间无法创建TLS，所以就有了隧道代理，它把浏览器的数据原样透传，这样就实现了通过中间代理和服务端进行TLS握手，然后进行加密传输")]),t._v(" "),_("p",[t._v("可能有人会问，那还要代理干嘛，直接请求服务器不是更好吗")]),t._v(" "),t._m(45),t._v(" "),t._m(46),t._v(" "),t._m(47),t._v(" "),t._m(48),t._v(" "),t._m(49),t._v(" "),t._m(50),t._v(" "),t._m(51),t._v(" "),_("p",[t._v("是一个能用首部，由代理服务器添加，适用于正向和反向代理，在请求和响应首部均可出现，这个消息首部可以用来追踪消息转发情况，防止循环请求，还可以识别在请求或响应传递链中消息发送者对于协议的支持能力")]),t._v(" "),t._m(52),t._v(" "),_("p",[t._v("记录客户端请求的来源IP，每经过一级代理(匿名代理除外)，代理服务器都会把这次请求的来源IP追加进去")]),t._v(" "),t._m(53),t._v(" "),_("p",[t._v("注意：与服务器直连的代理服务器的IP不会被追加进去，该代理可能过TCP连接的Remote Address字段获取到与服务器直连的代理服务器IP")]),t._v(" "),t._m(54),t._v(" "),_("p",[t._v("一般记录真实发出请求的客户端的IP，还有X-Forwarded-Host和X-Forwarded-Proto分别记录真实发出请求的客户端的域名和协议名")]),t._v(" "),t._m(55),t._v(" "),t._m(56),t._v(" "),t._m(57),t._v(" "),_("p",[t._v("X-Forwarded-For包含多个IP地址，每个值通过逗号+空格分开，最左边是最原始客户端的IP地址，中间如果有多层代理，每一层代理会将连接它的客户端IP追加在X-Forwarded-For右边")]),t._v(" "),_("p",[t._v("另外，要让Nginx支持X-Forwarded-For头，需要配置")]),t._v(" "),t._m(58),t._v(" "),t._m(59),t._v(" "),t._m(60),t._v(" "),t._m(61),t._v(" "),t._m(62),t._v(" "),t._m(63),t._v(" "),_("p",[t._v("工作在客户端的代理为正向代理。使用正向代理的时候，需要在客户端配置需要使用的代理服务器，正向代理对服务端透明。比如抓包工具Fiddler、Charles以及访问一些外网网站的代理工具都是正向代理")]),t._v(" "),t._m(64),t._v(" "),_("p",[t._v("正向代理通常用于")]),t._v(" "),t._m(65),t._v(" "),t._m(66),t._v(" "),_("p",[t._v("工作在服务端的代理称为反向代理。使用反向代理的时候，不需要在客户端进行设置，反向代理对客户端透明。如Nginx就是反向代理")]),t._v(" "),t._m(67),t._v(" "),_("p",[t._v("反向代理通常用于：")]),t._v(" "),t._m(68),t._v(" "),t._m(69),t._v(" "),_("p",[t._v("HTTPS 是超文本传输安全协议，即HTTP + SSL/TLS。说白了，就是一个加强版的HTTP")]),t._v(" "),t._m(70),t._v(" "),_("p",[t._v("HTTP本文开始讲了，所以我们要理解HTTPS的精华，就要先弄清楚这个SSL/TLS了")]),t._v(" "),t._m(71),t._v(" "),t._m(72),t._v(" "),_("p",[t._v("随便拿出一个加密套件举例，如：RSA-PSK-AES128-GCM-SHA256，就是长这样，代表什么意思呢，我们看图")]),t._v(" "),t._m(73),t._v(" "),t._m(74),t._v(" "),_("p",[t._v("为什么需要用到这么多算法呢？")]),t._v(" "),t._m(75),t._v(" "),t._m(76),t._v(" "),_("p",[t._v("为什么说https是安全的？")]),t._v(" "),_("p",[t._v("https一定是安全的吗？（考察https中间人劫持，我另一篇有关于详细介绍网络安全）")]),t._v(" "),_("p",[t._v("有什么解决办法？")]),t._v(" "),_("p",[t._v("https的证书校验过程是怎么样的？")]),t._v(" "),_("p",[t._v("证书校验用到了哪些算法？")]),t._v(" "),t._m(77),t._v(" "),_("p",[t._v("就是加密和解密使用同一个密钥。如AES、DES。加解密过程：")]),t._v(" "),t._m(78),t._v(" "),_("p",[t._v("问题是双方如何安全的传递两个随机数和加密方法，直接传给客户端，那过程中就很可能被窃取，别人就能成功解密拿到数据，往下看")]),t._v(" "),t._m(79),t._v(" "),t._m(80),t._v(" "),t._m(81),t._v(" "),_("p",[t._v("使用公钥反推出私钥是非常困难，但不是做不到，随着计算机运算能力提高，非对称密钥至少要2048位才能保证安全性，这就导致性能上要比对称加密要差很多")]),t._v(" "),t._m(82),t._v(" "),t._m(83),t._v(" "),_("p",[t._v("这样即便被截持，中间人没有私钥就拿不到pre-random，就无法生成最终密钥。")]),t._v(" "),_("p",[t._v("可又有问题来了，如果一开始就被DNS截持，我们拿到的公钥是中间人的，而不是服务器的，数据还是会被窃取，所以数字证书来了，往下看，先简单说一下摘要算法")]),t._v(" "),t._m(84),t._v(" "),_("p",[t._v("主要用于保证信息的完整性。常见的MD5算法、散列函数、哈希函数都属于这类算法，其特点就是单向性、无法反推原文")]),t._v(" "),_("p",[t._v("假如信息被截取，并重新生成了摘要，这时候就判断不出来是否被篡改了，所以需要给摘要也通过会话密钥进行加密，这样就看不到明文信息，保证了安全性，同时也保证了完整性")]),t._v(" "),t._m(85),t._v(" "),t._m(86),t._v(" "),t._m(87),t._v(" "),_("p",[t._v("这样不知不觉间信息就被人窃取了，所以在结合对称和非对称加密的基础上，又添加了数字证书认证的步骤，让服务器证明自己的身份")]),t._v(" "),_("p",[t._v("数字证书需要向有权威的认证机构(CA)获取授权给服务器。首先，服务器和CA机构分别有一对密钥(公钥和私钥)，然后是如何生成数字证书的呢？")]),t._v(" "),t._m(88),t._v(" "),_("p",[t._v("服务器配置好证书，以后客户端连接服务器，都先把证书发给客户端验证并获取服务器的公钥。")]),t._v(" "),t._m(89),t._v(" "),_("p",[t._v("使用CA公钥和声明的签名算法对CA中的签名进行解密，得到服务器公钥的摘要内容")]),t._v(" "),_("p",[t._v("再用摘要算法对证书里的服务器公钥生成摘要，再把这个摘要和上一步得到的摘要对比，如果一致说明证书合法，里面的公钥也是正确的，否则就是非法的")]),t._v(" "),t._m(90),t._v(" "),t._m(91),t._v(" "),_("p",[t._v("服务器发送证书，客户端验证证书")]),t._v(" "),t._m(92),t._v(" "),_("p",[t._v("服务器和客户端分别提供证书给对方，并互相验证对方的证书")]),t._v(" "),_("p",[t._v("不过大多数https服务器都是单向认证，如果服务器需要验证客户端的身份，一般通过用户名、密码、手机验证码等之类的凭证来验证。只有更高级别的要求的系统，比如大额网银转账等，就会提供双向认证的场景，来确保对客户身份提供认证性")]),t._v(" "),_("hr"),t._v(" "),t._m(93),t._v(" "),_("p",[_("a",{attrs:{href:"https://juejin.cn/post/6994629873985650696",target:"_blank",rel:"noopener noreferrer"}},[t._v("20分钟助你拿下HTTP和HTTPS，巩固你的HTTP知识体系"),_("OutboundLink")],1)]),t._v(" "),_("p",[_("a",{attrs:{href:"https://xxgblog.com/2018/10/12/x-forwarded-for-header-trick/",target:"_blank",rel:"noopener noreferrer"}},[t._v("利用X-Forwarded-For伪造客户端IP漏洞成因及防范"),_("OutboundLink")],1)])])}),[function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_1、http-的特点和缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、http-的特点和缺点"}},[this._v("#")]),this._v(" 1、HTTP 的特点和缺点")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("特点")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("无连接")]),this._v("：每一次请求都要连接一次，请求结束就会断掉，不会保持连接")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("无状态")]),this._v("：每一次请求都是独立的，请求结束不会记录连接的任何信息(提起裤子就不认人的意思)，减少了网络开销，这是优点也是缺点")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("灵活")]),this._v("：通过http协议中头部的Content-Type标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("简单快速")]),this._v("：发送请求访问某个资源时，只需传送请求方法和URL就可以了，使用简单，正由于http协议简单，使得http服务器的程序规模小，因而通信速度很快")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("缺点")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("无状态")]),this._v("：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("不安全")]),this._v("：明文传输可能被窃听不安全，缺少身份认证也可能遭遇伪装，还有缺少报文完整性验证可能遭到篡改")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("明文传输")]),this._v("：报文(header部分)使用的是明文，直接将信息暴露给了外界，WIFI陷阱就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("队头阻塞")]),this._v("：开启长连接(下面有讲)时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态(如何解决下面有讲)")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_2、http-报文组成部分"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、http-报文组成部分"}},[this._v("#")]),this._v(" 2、HTTP 报文组成部分")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("http报文")]),this._v("：由请求报文和响应报文组成")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("请求报文")]),this._v("：由请求行、请求头、空行、请求体四部分组成")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("响应报文")]),this._v("：由状态行、响应头、空行、响应体四部分组成")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("请求行：包含http方法，请求地址，http协议以及版本")]),t._v(" "),_("li",[t._v("请求头/响应头：就是一些key:value来告诉服务端我要哪些内容，要注意什么类型等，请求头/响应头每一个字段详解")]),t._v(" "),_("li",[t._v("空行：用来区分首部与实体，因为请求头都是key:value的格式，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了")]),t._v(" "),_("li",[t._v("请求体：请求的参数")]),t._v(" "),_("li",[t._v("状态行：包含http协议及版本、数字状态码、状态码英文名称")]),t._v(" "),_("li",[t._v("响应体：服务端返回的数据")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_3、get-和-post-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、get-和-post-的区别"}},[this._v("#")]),this._v(" 3、GET 和 POST 的区别")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("GET在浏览器回退时是无害的，而POST会再次发起请求")])]),t._v(" "),_("li",[_("p",[t._v("GET请求会被浏览器主动缓存，而POST不会，除非手动设置")])]),t._v(" "),_("li",[_("p",[t._v("GET请求参数会被安逗保留在浏览器历史记录里，而POST中的参数不会被保留")])]),t._v(" "),_("li",[_("p",[t._v("GET请求在URL中传递的参数有长度限制(浏览器限制大小不同)，而POST没有限制")])]),t._v(" "),_("li",[_("p",[t._v("GET参数通过URL传递，POST放在Request body中")])]),t._v(" "),_("li",[_("p",[t._v("GET产生的URL地址可以被收藏，而POST不可以")])]),t._v(" "),_("li",[_("p",[t._v("GET没有POST安全，因为GET请求参数直接暴露在URL上，所以不能用来传递敏感信息")])]),t._v(" "),_("li",[_("p",[t._v("GET请求只能进行URL编码，而POST支持多种编码方式")])]),t._v(" "),_("li",[_("p",[t._v("对参数的数据类型，GET只接受ASCII字符，而POST没有限制")])]),t._v(" "),_("li",[_("p",[t._v("GET产生一个TCP数据包，POST产生两个数据包(Firefox只发一次)。GET浏览器把 http header和data一起发出去，响应成功200，POST先发送header，响应100 continue，再发送data，响应成功200")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_4、什么是持久连接-长连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、什么是持久连接-长连接"}},[this._v("#")]),this._v(" 4、什么是持久连接/长连接")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("http1.0")]),this._v('协议采用的是"请求-应答"模式，当使用普通模式，每个请求/应答客户与服务器都要新建一个连接，完成之后立即断开连接(http协议为无连接的协议)')])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("http1.1")]),this._v("版本支持长连接，即请求头添加"),e("code",[this._v("Connection: Keep-Alive")]),this._v("，使用Keep-Alive模式(又称持久连接，连接复用)建立一个TCP连接后使客户端到服务端的连接持续有效，可以发送/接受多个http请求/响应，当出现对服务器的后续请求时，Keep-Alive功能避免了建立或者重新建立连接")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"/images/http/keep-alive.jpg",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("长连接优缺点")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("优点")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("减少CPU及内存的使用，因为不需要经常建立和关闭连接")])]),t._v(" "),_("li",[_("p",[t._v("支持管道化的请求及响应模式")])]),t._v(" "),_("li",[_("p",[t._v("减少网络堵塞，因为减少了TCP请求")])]),t._v(" "),_("li",[_("p",[t._v("减少了后续请求的响应时间，因为不需要等待建立TCP、握手、挥手、关闭TCP的过程")])]),t._v(" "),_("li",[_("p",[t._v("发生错误时，也可在不关闭连接的情况下进行错误提示")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("缺点")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("p",[this._v("一个长连接建立后，如果一直保持连接，对服务器来说是多么的浪费资源呀，而且长连接时间的长短，直接影响到服务器的并发数")])]),this._v(" "),e("li",[e("p",[this._v("还有就是可能造成队头堵塞(下面有讲)，造成信息延迟")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("如何避免长连接资源浪费")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("(1) 客户端请求头声明："),e("code",[this._v("Connection: close")]),this._v("，本次通信后就关闭连接")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("(2) 服务端配置：如Nginx，设置"),e("code",[this._v("keepalive_timeout")]),this._v("设置长连接超时时间，"),e("code",[this._v("keepalive_requests")]),this._v("设置长连接请求次数上限")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[_("code",[t._v("net.ipv4.tcp_keepalive_time = 60")]),t._v("，连接闲置60秒后，服务端尝试向客户端发送侦测包，判断TCP连接状态，如果没有收到ack反馈")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("net.ipv4.tcp_keepalive_intvl = 10")]),t._v("，就在10秒后再次尝试发送侦测包，直到收到ack反馈")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("net.ipv4.tcp_keepalive_probes = 5")]),t._v("，一共会尝试5次，要是都没有收到就关闭这个TCP连接了")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_5、什么是管线化-管道化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、什么是管线化-管道化"}},[this._v("#")]),this._v(" 5、什么是管线化(管道化)")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("管线化的特点")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("管线化机制通过持久连接完成，在http1.1版本才支持")])]),t._v(" "),_("li",[_("p",[t._v("只有GET请求和HEAD请求才可以进行管线化，而POST有所限制")])]),t._v(" "),_("li",[_("p",[t._v("初次创建连接时不应启动管线化机制，因为服务器不一定支持http1.1版本的协议")])]),t._v(" "),_("li",[_("p",[t._v("管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序就是请求的顺序")])]),t._v(" "),_("li",[_("p",[t._v("要求客户端和服务端都支持管线化，但并不要求服务端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可")])]),t._v(" "),_("li",[_("p",[t._v("由于上面提到的服务端问题，开户管线化很可能并不会带来大幅度的性能提升，而且很多服务端和代理程序对管线化的支持并不好，因为浏览器(Chrome/Firefox)默认并未开启管线化支持")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_6、如何解决-http-的队头阻塞问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、如何解决-http-的队头阻塞问题"}},[this._v("#")]),this._v(" 6、如何解决 HTTP 的队头阻塞问题")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("http1.0协议采用的是"),e("code",[this._v("请求-应答")]),this._v("模式，报文必须是"),e("code",[this._v("一发一收")]),this._v("，就形成了一个"),e("code",[this._v("先进先出")]),this._v("的串行队列，没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求最先处理，就导致如果队首的请求耗时过长，后面的请求就只能处于阻塞状态，这就是著名的队头阻塞问题。解决如下：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("并发连接")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("域名分片")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_7、说一下-http-代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、说一下-http-代理"}},[this._v("#")]),this._v(" 7、说一下 HTTP 代理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"普通代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#普通代理"}},[this._v("#")]),this._v(" 普通代理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"/images/http/proxy.jpg",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"隧道代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#隧道代理"}},[this._v("#")]),this._v(" 隧道代理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"/images/http/proxy-1.jpg",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"代理服务器，到底有什么好处呢？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理服务器，到底有什么好处呢？"}},[this._v("#")]),this._v(" 代理服务器，到底有什么好处呢？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("突破访问限制")]),this._v("：如访问一些单位或集团内部资源，或用国外代理服务器(翻墙)，就可以上国外网站看片等")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("安全性更高")]),this._v("：上网者可以通过这种方式隐藏自己的IP，免受攻击。还可以对数据过滤，对非法IP限流等")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("负载均衡")]),this._v("：客户端请求先到代理服务器，而代理服务器后面有多少源服务器，IP是多少，客户端是不知道的。因此，代理服务器收到请求后，通过特定的算法(随机算法、轮询、一致性hash、LUR(最近最少使用) 算法这里不细说了)把请求分发给不同的源服务器，让各个源服务器负载尽量均衡")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("缓存代理")]),this._v("：将内容缓存到代理服务器")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"代理最常见的请求头"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理最常见的请求头"}},[this._v("#")]),this._v(" 代理最常见的请求头")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("Via")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("X-Forwarded-For")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("X-Forwarded-For: client,proxy1,proxy2")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("X-Real-IP")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"代理中客户端ip伪造问题以及如何预防？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理中客户端ip伪造问题以及如何预防？"}},[this._v("#")]),this._v(" 代理中客户端IP伪造问题以及如何预防？")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("在Java中，获取客户端IP最直接的方式就是使用"),_("code",[t._v("request.getRemoteAddr()")]),t._v("。这种方式能获取到连接服务器的客户端IP，在中间没有代理的情况下，的确是最简单有效的方式。但是目前互联网Web应用很少会将应用服务器直接对外提供服务，一般都会有一层"),_("code",[t._v("Nginx")]),t._v("做反向代理和负载均衡，有的甚至可能有多层代理。在有反向代理的情况下，直接使用"),_("code",[t._v("request.getRemoteAddr()")]),t._v("获取到的IP地址是Nginx所在服务器的IP地址，而"),_("code",[t._v("不是")]),t._v("客户端的IP。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("为了解决上面的问题，很多HTTP代理会在HTTP协议头中添加"),e("code",[this._v("X-Forwarded-For")]),this._v("头，用来追踪请求的来源。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("如果客户端在发起请求时，请求头上带上一个伪造的X-Forwarded-For，由于后续每层代理只会追加而不会覆盖，那么最终到达应用服务器时，获取的左边第一个IP地址将会是客户端伪造的IP。也就是上面的Java代码中"),e("code",[this._v("getClientIp()")]),this._v("方法获取的IP地址很有可能是伪造的IP地址，如果一个投票系统用这种方式做的IP限制，那么很容易会被刷票")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("p",[this._v("在直接对外的Nginx反向代理服务器上配置 : "),e("code",[this._v("proxy_set_header X-Forwarded-For $remote_addr;")])])]),this._v(" "),e("li",[e("p",[this._v("如果有多层Nginx代理，内层的Nginx配置 : "),e("code",[this._v("proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;")])])])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"tip custom-block"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("在最外层Nginx（即直接对外提供服务的Nginx）使用$remote_addr代替上面的$proxy_add_x_forwarded_for，可以防止伪造X-Forwarded-For。")])]),t._v(" "),_("li",[_("p",[t._v("$proxy_add_x_forwarded_for会在原有X-Forwarded-For上追加IP，这就相当于给了伪造X-Forwarded-For的机会。而$remote_addr是获取的是直接TCP连接的客户端IP，这个是无法伪造的，即使客户端伪造也会被覆盖掉，而不是追加。")])]),t._v(" "),_("li",[_("p",[t._v("需要注意的是，如果有多层代理，只在直接对外访问的Nginx上配置X-Forwarded-For为$remote_addr，内层的Nginx还是要配置为$proxy_add_x_forwarded_for，不然内层的Nginx又会覆盖掉客户端的真实IP。")])]),t._v(" "),_("li",[_("p",[t._v("完成以上配置后，业务代码中再通过上面的getClientIp()方法，获取X-Forwarded-For最左边的IP地址即为真实的客户端地址，且客户端也无法伪造")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_8、正向代理和反向代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8、正向代理和反向代理"}},[this._v("#")]),this._v(" 8、正向代理和反向代理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"正向代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#正向代理"}},[this._v("#")]),this._v(" 正向代理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"/images/http/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.jpg",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("缓存")]),this._v(" "),e("li",[this._v("屏蔽某些不健康的网站")]),this._v(" "),e("li",[this._v("通过代理访问原本无法访问的网站")]),this._v(" "),e("li",[this._v("上网认证，对用户访问进行授权")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"反向代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#反向代理"}},[this._v("#")]),this._v(" 反向代理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"/images/http/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.jpg",alt:""}})])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("负载均衡")]),t._v(" "),_("li",[t._v("服务端缓存")]),t._v(" "),_("li",[t._v("流量隔离")]),t._v(" "),_("li",[t._v("日志")]),t._v(" "),_("li",[t._v("灰度发布")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_9、https"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9、https"}},[this._v("#")]),this._v(" 9、HTTPS")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"/images/http/https.png",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"/images/http/ssl.png",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("TLS")]),this._v(": 浏览器和服务器通信之前会先协商，选出它们都支持的加密套件，用来实现安全的通信")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"/images/http/%E5%8A%A0%E5%AF%86.jpg",alt:""}})])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[_("code",[t._v("RSA")]),t._v("：表示握手时用RSA算法交换密钥")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("PSK")]),t._v("：表示使用PSK算法签名")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("AES128-GCM")]),t._v("：表示使用AES256对称加密算法通信，密钥长度128，分组模式GCM。TLS 1.3中只剩下称加密算法有AES和CHACHA20，分组模式只剩下GCM和POLY1305")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("SHA256")]),t._v("：表示使用SHA256算法验证信息完整性并生成随机数。TLS 1.3中哈希摘要算法只剩下SHA256和SHA384了")])])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("为了保证安全，TLS需要保证信息的："),_("code",[t._v("机密性")]),t._v("、"),_("code",[t._v("可用性")]),t._v("、"),_("code",[t._v("完整性")]),t._v("、"),_("code",[t._v("认证性")]),t._v("、"),_("code",[t._v("不可否认性")]),t._v("，每一种算法都有其特定的用处")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_10、https-中-tls-的加密算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10、https-中-tls-的加密算法"}},[this._v("#")]),this._v(" 10、HTTPS 中 TLS 的加密算法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"对称加密算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对称加密算法"}},[this._v("#")]),this._v(" 对称加密算法")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("浏览器给服务器发送一个随机数"),_("code",[t._v("client-random")]),t._v("和一个支持的加密方法列表")]),t._v(" "),_("li",[t._v("服务器给浏览器返回另一个随机数"),_("code",[t._v("server-random")]),t._v("和双方都支持的加密方法")]),t._v(" "),_("li",[t._v("然后两者用加密方法将两个随机数混合生成密钥，这就是通信双方加解密的密钥")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"不对称加密算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不对称加密算法"}},[this._v("#")]),this._v(" 不对称加密算法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("就是一对密钥，有"),e("code",[this._v("公钥")]),this._v("(public key)和"),e("code",[this._v("私钥")]),this._v("(private key)，其中一个密钥加密后的数据，只能让另一个密钥进行解密。如RSA、ECDHE。加解密过程：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("p",[this._v("浏览器给服务器发送一个随机数client-random和一个支持的加密方法列表")])]),this._v(" "),e("li",[e("p",[this._v("服务器把另一个随机数server-random、加密方法、公钥传给浏览器")])]),this._v(" "),e("li",[e("p",[this._v("然后浏览器用公钥将两个随机数加密，生成密钥，这个密钥只能用私钥解密")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("TLS实际用的是两种算法的混合加密。通过 非对称加密算法 交换 对称加密算法 的密钥，交换完成后，再使用对称加密进行加解密传输数据。这样就保证了会话的机密性")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("浏览器给服务器发送一个随机数client-random和一个支持的加密方法列表")])]),t._v(" "),_("li",[_("p",[t._v("服务器把另一个随机数server-random、加密方法、公钥传给浏览器")])]),t._v(" "),_("li",[_("p",[t._v("浏览器又生成另一个随机数pre-random，并用公钥加密后传给服务器")])]),t._v(" "),_("li",[_("p",[t._v("服务器再用私钥解密，得到pre-random")])]),t._v(" "),_("li",[_("p",[t._v("浏览器和服务器都将三个随机数用加密方法混合生成最终密钥")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"摘要算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#摘要算法"}},[this._v("#")]),this._v(" 摘要算法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_11、如何保证数据不被篡改？签名原理和证书"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11、如何保证数据不被篡改？签名原理和证书"}},[this._v("#")]),this._v(" 11、如何保证数据不被篡改？签名原理和证书?")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"数字证书-数字签名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数字证书-数字签名"}},[this._v("#")]),this._v(" 数字证书(数字签名)")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("它可以帮我们"),e("code",[this._v("验证服务器身份")]),this._v("。因为如果没有验证的话，就可能被中间人劫持，假如请求被中间人截获，中间人把他自己的公钥给了客户端，客户端收到公钥就把信息发给中间人了，中间人解密拿到数据后，再请求实际服务器，拿到服务器公钥，再把信息发给服务器")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("CA机构通过摘要算法生成服务器公钥的摘要(哈希摘要)")]),t._v(" "),_("li",[t._v("CA机构通过CA私钥及特定的签名算法加密摘要，生成签名")]),t._v(" "),_("li",[t._v("把"),_("code",[t._v("签名")]),t._v("、"),_("code",[t._v("服务器公钥")]),t._v("等信息打包放入"),_("code",[t._v("数字证书")]),t._v("，并返回给服务器")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"证书验证流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#证书验证流程"}},[this._v("#")]),this._v(" 证书验证流程")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("证书认证又分为"),e("code",[this._v("单向认证")]),this._v("和"),e("code",[this._v("双向认证")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"单向认证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单向认证"}},[this._v("#")]),this._v(" 单向认证")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"双向认证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双向认证"}},[this._v("#")]),this._v(" 双向认证")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("参考文章")])])}],!1,null,null,null);e.default=s.exports}}]);