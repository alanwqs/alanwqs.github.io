<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue3知识总结 | 前端小时</title>
    <meta name="description" content="">
    <link rel="icon" href="/images/photo.jpg">
  <link rel="manifest" href="/images/photo.jpg">
  <link rel="apple-touch-icon" href="/images/photo.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.6aaa91c1.css" as="style"><link rel="preload" href="/assets/js/app.6c60143e.js" as="script"><link rel="preload" href="/assets/js/67.b7251c18.js" as="script"><link rel="prefetch" href="/assets/js/10.6b10a528.js"><link rel="prefetch" href="/assets/js/11.d7afebf9.js"><link rel="prefetch" href="/assets/js/12.f91b76fa.js"><link rel="prefetch" href="/assets/js/13.ee8d44a0.js"><link rel="prefetch" href="/assets/js/14.5fd9bab5.js"><link rel="prefetch" href="/assets/js/15.71185e7c.js"><link rel="prefetch" href="/assets/js/16.ae6001aa.js"><link rel="prefetch" href="/assets/js/17.79fc5361.js"><link rel="prefetch" href="/assets/js/18.42f30bb4.js"><link rel="prefetch" href="/assets/js/19.ef32d8a4.js"><link rel="prefetch" href="/assets/js/2.858e80da.js"><link rel="prefetch" href="/assets/js/20.5a98ceda.js"><link rel="prefetch" href="/assets/js/21.76e4f6fa.js"><link rel="prefetch" href="/assets/js/22.3f95dcd3.js"><link rel="prefetch" href="/assets/js/23.ba4d25bc.js"><link rel="prefetch" href="/assets/js/24.6a597996.js"><link rel="prefetch" href="/assets/js/25.227fb7ef.js"><link rel="prefetch" href="/assets/js/26.71946d04.js"><link rel="prefetch" href="/assets/js/27.db9dae04.js"><link rel="prefetch" href="/assets/js/28.ed68d8d4.js"><link rel="prefetch" href="/assets/js/29.63bc6416.js"><link rel="prefetch" href="/assets/js/3.3ede1f01.js"><link rel="prefetch" href="/assets/js/30.a9d05c1f.js"><link rel="prefetch" href="/assets/js/31.48f62c42.js"><link rel="prefetch" href="/assets/js/32.27c58484.js"><link rel="prefetch" href="/assets/js/33.f712075e.js"><link rel="prefetch" href="/assets/js/34.46e288c9.js"><link rel="prefetch" href="/assets/js/35.970c7f61.js"><link rel="prefetch" href="/assets/js/36.3644495c.js"><link rel="prefetch" href="/assets/js/37.0331be5a.js"><link rel="prefetch" href="/assets/js/38.64813422.js"><link rel="prefetch" href="/assets/js/39.f702b220.js"><link rel="prefetch" href="/assets/js/4.d3babcf5.js"><link rel="prefetch" href="/assets/js/40.0ddc56cc.js"><link rel="prefetch" href="/assets/js/41.46b314f4.js"><link rel="prefetch" href="/assets/js/42.7c392dca.js"><link rel="prefetch" href="/assets/js/43.87c578ae.js"><link rel="prefetch" href="/assets/js/44.4af6e740.js"><link rel="prefetch" href="/assets/js/45.e7e0dc1e.js"><link rel="prefetch" href="/assets/js/46.8cf9aafb.js"><link rel="prefetch" href="/assets/js/47.4fdbccab.js"><link rel="prefetch" href="/assets/js/48.17e8c14f.js"><link rel="prefetch" href="/assets/js/49.3fefb3c7.js"><link rel="prefetch" href="/assets/js/5.9485e149.js"><link rel="prefetch" href="/assets/js/50.eef5a0ce.js"><link rel="prefetch" href="/assets/js/51.d13fd75c.js"><link rel="prefetch" href="/assets/js/52.369ab3aa.js"><link rel="prefetch" href="/assets/js/53.cea9ac87.js"><link rel="prefetch" href="/assets/js/54.f9bc320e.js"><link rel="prefetch" href="/assets/js/55.7ab13cf8.js"><link rel="prefetch" href="/assets/js/56.16470a4a.js"><link rel="prefetch" href="/assets/js/57.d925d174.js"><link rel="prefetch" href="/assets/js/58.80cf022a.js"><link rel="prefetch" href="/assets/js/59.ec44b198.js"><link rel="prefetch" href="/assets/js/6.f5b22e2d.js"><link rel="prefetch" href="/assets/js/60.0880c9ba.js"><link rel="prefetch" href="/assets/js/61.991dc017.js"><link rel="prefetch" href="/assets/js/62.4ff6f265.js"><link rel="prefetch" href="/assets/js/63.02ad01a3.js"><link rel="prefetch" href="/assets/js/64.35e5afd7.js"><link rel="prefetch" href="/assets/js/65.f8b832c1.js"><link rel="prefetch" href="/assets/js/66.31422d32.js"><link rel="prefetch" href="/assets/js/68.0d2e42a1.js"><link rel="prefetch" href="/assets/js/69.34fe27a6.js"><link rel="prefetch" href="/assets/js/7.9bf19d03.js"><link rel="prefetch" href="/assets/js/8.f79eb03f.js"><link rel="prefetch" href="/assets/js/9.90611952.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6aaa91c1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端小时</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">算法题库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/leetcodeTop.html" class="nav-link">LeetCode TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/byte-dance.html" class="nav-link">字节 TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/methods.html" class="nav-link">LeetCode 解题方法</a></li><li class="dropdown-item"><!----> <a href="/algorithm/tencentTop100.html" class="nav-link">腾讯 TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/aliTop100.html" class="nav-link">阿里 TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/front-end.html" class="nav-link">前端手写代码</a></li><li class="dropdown-item"><!----> <a href="/algorithm/class.html" class="nav-link">跟着Carl学算法</a></li><li class="dropdown-item"><!----> <a href="/algorithm/tencent.html" class="nav-link">腾讯精选练习 50 题</a></li><li class="dropdown-item"><!----> <a href="/algorithm/2020.html" class="nav-link">2020 名企高频面试题</a></li><li class="dropdown-item"><!----> <a href="/algorithm/middle.html" class="nav-link">中级算法</a></li></ul></div></div><div class="nav-item"><a href="http://blog.alanwu.website/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧版博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">算法题库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/leetcodeTop.html" class="nav-link">LeetCode TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/byte-dance.html" class="nav-link">字节 TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/methods.html" class="nav-link">LeetCode 解题方法</a></li><li class="dropdown-item"><!----> <a href="/algorithm/tencentTop100.html" class="nav-link">腾讯 TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/aliTop100.html" class="nav-link">阿里 TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/front-end.html" class="nav-link">前端手写代码</a></li><li class="dropdown-item"><!----> <a href="/algorithm/class.html" class="nav-link">跟着Carl学算法</a></li><li class="dropdown-item"><!----> <a href="/algorithm/tencent.html" class="nav-link">腾讯精选练习 50 题</a></li><li class="dropdown-item"><!----> <a href="/algorithm/2020.html" class="nav-link">2020 名企高频面试题</a></li><li class="dropdown-item"><!----> <a href="/algorithm/middle.html" class="nav-link">中级算法</a></li></ul></div></div><div class="nav-item"><a href="http://blog.alanwu.website/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧版博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Vue3知识总结</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/vue/vue3.html#一、vue3-0-proxy-api" class="sidebar-link">一、Vue3.0 Proxy API</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue3.html#二、vue3-0-编译做了哪些优化？" class="sidebar-link">二、Vue3.0 编译做了哪些优化？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue3.html#三、vue3-0新特性-composition-api" class="sidebar-link">三、Vue3.0新特性 Composition API</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue3.html#四、vue3-0是如何变得更快的？" class="sidebar-link">四、Vue3.0是如何变得更快的？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue3.html#_1、diff方法优化" class="sidebar-link">1、diff方法优化</a></li><li class="sidebar-sub-header"><a href="/vue/vue3.html#_2、hoiststatic-静态提升" class="sidebar-link">2、hoistStatic 静态提升</a></li><li class="sidebar-sub-header"><a href="/vue/vue3.html#_3、cachehandlers-事件侦听器缓存" class="sidebar-link">3、cacheHandlers 事件侦听器缓存</a></li><li class="sidebar-sub-header"><a href="/vue/vue3.html#_4、ssr优化" class="sidebar-link">4、SSR优化</a></li><li class="sidebar-sub-header"><a href="/vue/vue3.html#_5、tree-shaking" class="sidebar-link">5、tree-shaking</a></li></ul></li><li><a href="/vue/vue3.html#五、vue3-0-如何进行性能提升？" class="sidebar-link">五、Vue3.0 如何进行性能提升？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue3.html#六、vue3-0-响应式系统的实现原理" class="sidebar-link">六、vue3.0 响应式系统的实现原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue3.html#_1、reactive" class="sidebar-link">1、reactive</a></li><li class="sidebar-sub-header"><a href="/vue/vue3.html#_2、effect" class="sidebar-link">2、effect</a></li><li class="sidebar-sub-header"><a href="/vue/vue3.html#_3、track" class="sidebar-link">3、track</a></li><li class="sidebar-sub-header"><a href="/vue/vue3.html#_4、trigger" class="sidebar-link">4、trigger</a></li></ul></li><li><a href="/vue/vue3.html#七、vue3-0-比-vue2-0-优势" class="sidebar-link">七、vue3.0 比 vue2.0 优势</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue3.html#八、vue3-0-如何理解ref-toref和torefs？" class="sidebar-link">八、vue3.0 如何理解ref toRef和toRefs？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue3.html#九、watch和watcheffect的区别是什么？" class="sidebar-link">九、watch和watchEffect的区别是什么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue3.html#十、setup中如何获取组件实例？" class="sidebar-link">十、setup中如何获取组件实例？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue3.html#十一、teleport-和-suspense-是什么？" class="sidebar-link">十一、Teleport 和 Suspense 是什么？</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="一、vue3-0-proxy-api"><a href="#一、vue3-0-proxy-api" class="header-anchor">#</a> 一、Vue3.0 Proxy API</h2> <h4 id="defineproperty只能针对单例属性做监听"><a href="#defineproperty只能针对单例属性做监听" class="header-anchor">#</a> defineProperty只能针对单例属性做监听</h4> <ul><li><p>Vue2.x中的响应式实现正是基于defineProperty中的descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter</p></li> <li><p>这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因，在Vue中使用下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到setter监听的，这是defineProperty的局限性</p></li></ul> <h4 id="proxy-api的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，-这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码"><a href="#proxy-api的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，-这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码" class="header-anchor">#</a> Proxy API的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码</h4> <ul><li>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</li></ul> <h4 id="响应式是惰性的"><a href="#响应式是惰性的" class="header-anchor">#</a> 响应式是惰性的</h4> <ul><li><p>在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗</p></li> <li><p>在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗</p></li> <li><p>基础用法：</p></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> datas <span class="token operator">=</span> <span class="token punctuation">{</span>
    num<span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>datas<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> target<span class="token punctuation">[</span>property<span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">[</span>property<span class="token punctuation">]</span> <span class="token operator">+=</span> value
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="二、vue3-0-编译做了哪些优化？"><a href="#二、vue3-0-编译做了哪些优化？" class="header-anchor">#</a> 二、Vue3.0 编译做了哪些优化？</h2> <h4 id="生成-block-tree"><a href="#生成-block-tree" class="header-anchor">#</a> 生成 Block tree</h4> <ul><li><p>Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部 需要遍历该组件的整个 vnode 树。
在2.0里，渲染效率的快慢与组件大小成正相关：组件越大，渲染效率越慢。并且，对于一些静态节点，又无数据更新，这些遍历都是性能浪费</p></li> <li><p>Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了 Block tree。
Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个 区块内部的节点结构是固定的，每个区块只需要追踪自身包含的动态节点</p></li> <li><p>在3.0里，渲染效率不再与模板大小成正相关，而是与模板中动态节点的数量成正相关</p></li></ul> <h4 id="slot-编译优化"><a href="#slot-编译优化" class="header-anchor">#</a> slot 编译优化</h4> <ul><li><p>Vue.js 2.x 中，如果有一个组件传入了slot，那么每次父组件更新的时候，会强制使子组件update，造成性能的浪费</p></li> <li><p>Vue.js 3.0 优化了slot的生成，使得非动态slot中属性的更新只会触发子组件的更新，动态slot指的是在slot上面使用v-if，v-for，动态slot名字等会导致slot产生运行时动态变化但是又无法被子组件track的操作</p></li></ul> <h4 id="diff算法优化"><a href="#diff算法优化" class="header-anchor">#</a> diff算法优化</h4> <p>稍后...</p> <h2 id="三、vue3-0新特性-composition-api"><a href="#三、vue3-0新特性-composition-api" class="header-anchor">#</a> 三、Vue3.0新特性 Composition API</h2> <h4 id="vue-composition-api-基本使用"><a href="#vue-composition-api-基本使用" class="header-anchor">#</a> Vue Composition API 基本使用</h4> <ul><li><p>Vue Composition API 围绕一个新的组件选项 setup 而创建。setup() 为 Vue 组件提供了状态、计算值、watcher 和生命周期钩子</p></li> <li><p>并没有让原来的 API（Options-based API）消失。允许开发者 结合使用新旧两种 API（向下兼容）</p></li></ul> <h4 id="与options-api区别"><a href="#与options-api区别" class="header-anchor">#</a> 与Options Api区别</h4> <ul><li><p>包含一个描述组件选项（data、methods、props等）的对象 options</p></li> <li><p>API开发复杂组件，同一个功能逻辑的代码被拆分到不同选项</p></li> <li><p>使用mixin重用公用代码，也有问题：命名冲突，数据来源不清晰</p></li></ul> <h4 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h4> <ul><li><p>React hook 底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks</p></li> <li><p>vue hook 只会被注册调用一次，vue 能避开这些麻烦的问题，原因在于它对数据的响应是基于proxy的，对数据直接代理观察。
（这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题）</p></li> <li><p>react 中，数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react复杂程度会高一些</p></li></ul> <h4 id="优势"><a href="#优势" class="header-anchor">#</a> 优势</h4> <ul><li><p>vue3 新增的一组 api，它是基于函数的 api，可以更灵活的组织组件的逻辑，解决options api在大型项目中，options api不好拆分和重用的问题</p></li> <li><p>小型项目，业务逻辑简单，用Options API，中大型项目，业务逻辑复杂的，用Composition API</p></li></ul> <h2 id="四、vue3-0是如何变得更快的？"><a href="#四、vue3-0是如何变得更快的？" class="header-anchor">#</a> 四、Vue3.0是如何变得更快的？</h2> <h3 id="_1、diff方法优化"><a href="#_1、diff方法优化" class="header-anchor">#</a> 1、diff方法优化</h3> <ul><li><p>Vue2.x 中的虚拟dom是进行全量的对比。</p></li> <li><p>Vue3.0 中新增了静态标记（PatchFlag）：在与上次虚拟结点进行对比的时候，只对比带有patch flag的节点，并且可以通过flag 的信息得知当前节点要对比的具体内容化</p></li> <li><p>编译模板时，动态节点做标记；diff时，区分静态节点和不同类型的动态节点</p></li></ul> <h3 id="_2、hoiststatic-静态提升"><a href="#_2、hoiststatic-静态提升" class="header-anchor">#</a> 2、hoistStatic 静态提升</h3> <ul><li><p>Vue2.x : 无论元素是否参与更新，每次都会重新创建。</p></li> <li><p>Vue3.0 : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用。</p></li> <li><p>将静态节点的定义，提升到父作用域，缓存起来，空间换时间；多个相邻的静态节点，会被合并起来，编译优化</p></li></ul> <h3 id="_3、cachehandlers-事件侦听器缓存"><a href="#_3、cachehandlers-事件侦听器缓存" class="header-anchor">#</a> 3、cacheHandlers 事件侦听器缓存</h3> <ul><li>缓存事件，默认情况下onClick会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可</li></ul> <h3 id="_4、ssr优化"><a href="#_4、ssr优化" class="header-anchor">#</a> 4、SSR优化</h3> <ul><li>静态节点直接输出为dom，绕过vdom</li></ul> <h3 id="_5、tree-shaking"><a href="#_5、tree-shaking" class="header-anchor">#</a> 5、tree-shaking</h3> <ul><li>编译时，按需引入API</li></ul> <h2 id="五、vue3-0-如何进行性能提升？"><a href="#五、vue3-0-如何进行性能提升？" class="header-anchor">#</a> 五、Vue3.0 如何进行性能提升？</h2> <h4 id="响应式系统提升"><a href="#响应式系统提升" class="header-anchor">#</a> 响应式系统提升</h4> <p>vue2在初始化的时候，对data中的每个属性使用definepropery调用getter和setter使之变为响应式对象。如果属性值为对象，还会递归调用defineproperty使之变为响应式对象</p> <p>vue3使用proxy对象重写响应式。proxy的性能本来比defineproperty好，proxy可以拦截属性的访问、赋值、删除等操作，不需要初始化的时候遍历所有属性，另外有多层属性嵌套的话，只有访问某个属性的时候，才会递归处理下一级的属性</p> <p><code>优势</code></p> <ul><li><p>可以监听动态新增的属性</p></li> <li><p>可以监听删除的属性</p></li> <li><p>可以监听数组的索引和 length 属性</p></li></ul> <h4 id="编译优化"><a href="#编译优化" class="header-anchor">#</a> 编译优化</h4> <ul><li><p>优化编译和重写虚拟dom，让首次渲染和更新dom性能有更大的提升 vue2 通过标记静态根节点,优化 diff 算法 vue3 标记和提升所有静态根节点,diff 的时候只比较动态节点内容</p></li> <li><p>Fragments, 模板里面不用创建唯一根节点,可以直接放同级标签和文本内容</p></li> <li><p>静态提升，patch flag, 跳过静态节点,直接对比动态节点,缓存事件处理函数</p></li></ul> <h4 id="源码体积的优化"><a href="#源码体积的优化" class="header-anchor">#</a> 源码体积的优化</h4> <ul><li>vue3移除了一些不常用的api，例如：inline-template、filter等 使用tree-shaking</li></ul> <h2 id="六、vue3-0-响应式系统的实现原理"><a href="#六、vue3-0-响应式系统的实现原理" class="header-anchor">#</a> 六、vue3.0 响应式系统的实现原理</h2> <h3 id="_1、reactive"><a href="#_1、reactive" class="header-anchor">#</a> 1、reactive</h3> <p>设置对象为响应式对象。接收一个参数，判断这参数是否是对象。不是对象则直接返回这个参数，不做响应式处理。创建拦截器handerler，设置get/set/deleteproperty</p> <h4 id="get"><a href="#get" class="header-anchor">#</a> <code>get</code></h4> <ul><li><p>收集依赖（track）</p></li> <li><p>如果当前 key 的值是对象，则为当前 key 的对</p></li> <li><p>象创建拦截器 handler, 设置 get/set/deleteProperty</p></li> <li><p>如果当前的 key 的值不是对象，则返回当前 key 的值</p></li></ul> <h4 id="set"><a href="#set" class="header-anchor">#</a> <code>set</code></h4> <ul><li><p>设置的新值和老值不相等时，更新为新值，并触发更新（trigger）。</p></li> <li><p>deleteProperty 当前对象有这个 key 的时候，删除这个 key 并触发更新（trigger）</p></li></ul> <h3 id="_2、effect"><a href="#_2、effect" class="header-anchor">#</a> 2、effect</h3> <p>接收一个函数作为参数。作用是：访问响应式对象属性时去收集依赖</p> <h3 id="_3、track"><a href="#_3、track" class="header-anchor">#</a> 3、track</h3> <p>接收两个参数：target 和 key</p> <ul><li><p>如果没有 activeEffect，则说明没有创建 effect 依赖</p></li> <li><p>如果有 activeEffect，则去判断 WeakMap 集合中是否有 target 属性</p></li> <li><p>WeakMap 集合中没有 target 属性，则 set(target, (depsMap = new Map()))</p></li> <li><p>WeakMap 集合中有 target 属性，则判断 target 属性的 map 值的 depsMap 中是否有 key 属性</p></li> <li><p>depsMap 中没有 key 属性，则 set(key, (dep = new Set()))</p></li> <li><p>depsMap 中有 key 属性，则添加这个 activeEffect</p></li></ul> <h3 id="_4、trigger"><a href="#_4、trigger" class="header-anchor">#</a> 4、trigger</h3> <ul><li>判断 WeakMap 中是否有 target 属性，WeakMap 中有 target 属性，则判断 target 属性的 map 值中是否有 key 属性，有的话循环触发收集的 effect()</li></ul> <h2 id="七、vue3-0-比-vue2-0-优势"><a href="#七、vue3-0-比-vue2-0-优势" class="header-anchor">#</a> 七、vue3.0 比 vue2.0 优势</h2> <ul><li><p>性能更好</p></li> <li><p>体积更小</p></li> <li><p>更好的ts支持</p></li> <li><p>更好的代码组织</p></li> <li><p>更好的逻辑抽离</p></li> <li><p>更多新的功能</p></li></ul> <h2 id="八、vue3-0-如何理解ref-toref和torefs？"><a href="#八、vue3-0-如何理解ref-toref和torefs？" class="header-anchor">#</a> 八、vue3.0 如何理解ref toRef和toRefs？</h2> <ol><li><p>ref</p> <ol><li>生成值类型的响应式数据</li> <li>可用于模板和reactive</li> <li>通过.value修改值</li></ol></li> <li><p>toRef</p> <ol><li>针对一个响应式对象（reactive封装）的prop</li> <li>创建一个ref，具有响应式</li> <li>两者保持引用关系</li></ol></li> <li><p>toRefs，避免模板中导出都是state</p> <ol><li>将响应式对象（reactive封装）转换成普通对象</li> <li>对象的每个prop都是对应的ref</li> <li>两者保持引用关系</li></ol></li> <li><p>最佳使用方式</p> <ol><li>用reactive做对象的响应式，用ref做值类型的响应式</li> <li>setup中返回toRefs(state)，或者toRef(state, 'prop')</li> <li>ref的变量命名都用xxxRef</li> <li>合成函数返回响应式对象时，用toRefs</li></ol></li></ol> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <ol><li><p>为何需要ref？</p> <ol><li>返回值类型，会丢失响应式</li> <li>setup、computed、合成函数，都有可能返回值类型</li> <li>Vue如果不定义ref，用户将自定义ref，反而混乱</li></ol></li> <li><p>为何需要.value？</p> <ol><li>ref是一个对象（不丢失响应式），value存储值</li> <li>通过.value属性的get和set实现响应式</li> <li>用于模板、reactive时，不需要.value，其他情况都需要</li></ol></li> <li><p>为何需要toRef toRefs</p> <ol><li>初衷：不丢失响应式的情况下，把对象数据进行分解和扩散</li> <li>前提：针对的事响应式对象，不是普通对象</li> <li>注意：不创造响应式，而是延续响应式</li></ol></li></ol></div> <h2 id="九、watch和watcheffect的区别是什么？"><a href="#九、watch和watcheffect的区别是什么？" class="header-anchor">#</a> 九、watch和watchEffect的区别是什么？</h2> <ol><li><p>二者都可以监听属性变化</p></li> <li><p>watch需要明确监听哪个属性</p></li> <li><p>watchEffect会根据其中的属性，自动监听其变化</p></li></ol> <h2 id="十、setup中如何获取组件实例？"><a href="#十、setup中如何获取组件实例？" class="header-anchor">#</a> 十、setup中如何获取组件实例？</h2> <ol><li><p>setup和其他Composition API中都没有this</p></li> <li><p>在Options API中仍然可以使用this</p></li> <li><p>Composition API中可以使用<code>getCurrentInstance</code>方法获取</p></li></ol> <h2 id="十一、teleport-和-suspense-是什么？"><a href="#十一、teleport-和-suspense-是什么？" class="header-anchor">#</a> 十一、Teleport 和 Suspense 是什么？</h2> <ul><li><p>Teleport 是一种能够将我们的模板渲染至指定 DOM 节点，不受父级 style 、v-show 等属性影响，但 data、prop 数据依旧能够共用的技术</p></li> <li><p><code>Suspense</code> 是一个特殊的组件，它将呈现回退内容，而不是对于的组件，直到满足条件为止，这种情况通常是组件 setup 功能中发生的异步操作或者是异步组件中使用</p></li> <li><p>使用场景：父组件展示的内容包含异步的子组件，异步的子组件需要一定的时间才可以加载并展示，这时就需要一个组件处理一些占位逻辑或者加载异常逻辑</p></li></ul> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code>// vue2.x
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>!loading<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
            ...
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>loading<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Loading...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

// vue3.x
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Suspense</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Suspended-component</span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">#fallback</span><span class="token punctuation">&gt;</span></span>
        Loading...
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Suspense</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.6c60143e.js" defer></script><script src="/assets/js/67.b7251c18.js" defer></script>
  </body>
</html>
