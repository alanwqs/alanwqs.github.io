<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Webpack | 前端小时</title>
    <meta name="description" content="">
    <link rel="icon" href="/images/photo.jpg">
  <link rel="manifest" href="/images/photo.jpg">
  <link rel="apple-touch-icon" href="/images/photo.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.6aaa91c1.css" as="style"><link rel="preload" href="/assets/js/app.6c60143e.js" as="script"><link rel="preload" href="/assets/js/68.0d2e42a1.js" as="script"><link rel="prefetch" href="/assets/js/10.6b10a528.js"><link rel="prefetch" href="/assets/js/11.d7afebf9.js"><link rel="prefetch" href="/assets/js/12.f91b76fa.js"><link rel="prefetch" href="/assets/js/13.ee8d44a0.js"><link rel="prefetch" href="/assets/js/14.5fd9bab5.js"><link rel="prefetch" href="/assets/js/15.71185e7c.js"><link rel="prefetch" href="/assets/js/16.ae6001aa.js"><link rel="prefetch" href="/assets/js/17.79fc5361.js"><link rel="prefetch" href="/assets/js/18.42f30bb4.js"><link rel="prefetch" href="/assets/js/19.ef32d8a4.js"><link rel="prefetch" href="/assets/js/2.858e80da.js"><link rel="prefetch" href="/assets/js/20.5a98ceda.js"><link rel="prefetch" href="/assets/js/21.76e4f6fa.js"><link rel="prefetch" href="/assets/js/22.3f95dcd3.js"><link rel="prefetch" href="/assets/js/23.ba4d25bc.js"><link rel="prefetch" href="/assets/js/24.6a597996.js"><link rel="prefetch" href="/assets/js/25.227fb7ef.js"><link rel="prefetch" href="/assets/js/26.71946d04.js"><link rel="prefetch" href="/assets/js/27.db9dae04.js"><link rel="prefetch" href="/assets/js/28.ed68d8d4.js"><link rel="prefetch" href="/assets/js/29.63bc6416.js"><link rel="prefetch" href="/assets/js/3.3ede1f01.js"><link rel="prefetch" href="/assets/js/30.a9d05c1f.js"><link rel="prefetch" href="/assets/js/31.48f62c42.js"><link rel="prefetch" href="/assets/js/32.27c58484.js"><link rel="prefetch" href="/assets/js/33.f712075e.js"><link rel="prefetch" href="/assets/js/34.46e288c9.js"><link rel="prefetch" href="/assets/js/35.970c7f61.js"><link rel="prefetch" href="/assets/js/36.3644495c.js"><link rel="prefetch" href="/assets/js/37.0331be5a.js"><link rel="prefetch" href="/assets/js/38.64813422.js"><link rel="prefetch" href="/assets/js/39.f702b220.js"><link rel="prefetch" href="/assets/js/4.d3babcf5.js"><link rel="prefetch" href="/assets/js/40.0ddc56cc.js"><link rel="prefetch" href="/assets/js/41.46b314f4.js"><link rel="prefetch" href="/assets/js/42.7c392dca.js"><link rel="prefetch" href="/assets/js/43.87c578ae.js"><link rel="prefetch" href="/assets/js/44.4af6e740.js"><link rel="prefetch" href="/assets/js/45.e7e0dc1e.js"><link rel="prefetch" href="/assets/js/46.8cf9aafb.js"><link rel="prefetch" href="/assets/js/47.4fdbccab.js"><link rel="prefetch" href="/assets/js/48.17e8c14f.js"><link rel="prefetch" href="/assets/js/49.3fefb3c7.js"><link rel="prefetch" href="/assets/js/5.9485e149.js"><link rel="prefetch" href="/assets/js/50.eef5a0ce.js"><link rel="prefetch" href="/assets/js/51.d13fd75c.js"><link rel="prefetch" href="/assets/js/52.369ab3aa.js"><link rel="prefetch" href="/assets/js/53.cea9ac87.js"><link rel="prefetch" href="/assets/js/54.f9bc320e.js"><link rel="prefetch" href="/assets/js/55.7ab13cf8.js"><link rel="prefetch" href="/assets/js/56.16470a4a.js"><link rel="prefetch" href="/assets/js/57.d925d174.js"><link rel="prefetch" href="/assets/js/58.80cf022a.js"><link rel="prefetch" href="/assets/js/59.ec44b198.js"><link rel="prefetch" href="/assets/js/6.f5b22e2d.js"><link rel="prefetch" href="/assets/js/60.0880c9ba.js"><link rel="prefetch" href="/assets/js/61.991dc017.js"><link rel="prefetch" href="/assets/js/62.4ff6f265.js"><link rel="prefetch" href="/assets/js/63.02ad01a3.js"><link rel="prefetch" href="/assets/js/64.35e5afd7.js"><link rel="prefetch" href="/assets/js/65.f8b832c1.js"><link rel="prefetch" href="/assets/js/66.31422d32.js"><link rel="prefetch" href="/assets/js/67.b7251c18.js"><link rel="prefetch" href="/assets/js/69.34fe27a6.js"><link rel="prefetch" href="/assets/js/7.9bf19d03.js"><link rel="prefetch" href="/assets/js/8.f79eb03f.js"><link rel="prefetch" href="/assets/js/9.90611952.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6aaa91c1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端小时</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">算法题库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/leetcodeTop.html" class="nav-link">LeetCode TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/byte-dance.html" class="nav-link">字节 TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/methods.html" class="nav-link">LeetCode 解题方法</a></li><li class="dropdown-item"><!----> <a href="/algorithm/tencentTop100.html" class="nav-link">腾讯 TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/aliTop100.html" class="nav-link">阿里 TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/front-end.html" class="nav-link">前端手写代码</a></li><li class="dropdown-item"><!----> <a href="/algorithm/class.html" class="nav-link">跟着Carl学算法</a></li><li class="dropdown-item"><!----> <a href="/algorithm/tencent.html" class="nav-link">腾讯精选练习 50 题</a></li><li class="dropdown-item"><!----> <a href="/algorithm/2020.html" class="nav-link">2020 名企高频面试题</a></li><li class="dropdown-item"><!----> <a href="/algorithm/middle.html" class="nav-link">中级算法</a></li></ul></div></div><div class="nav-item"><a href="http://blog.alanwu.website/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧版博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">算法题库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/leetcodeTop.html" class="nav-link">LeetCode TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/byte-dance.html" class="nav-link">字节 TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/methods.html" class="nav-link">LeetCode 解题方法</a></li><li class="dropdown-item"><!----> <a href="/algorithm/tencentTop100.html" class="nav-link">腾讯 TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/aliTop100.html" class="nav-link">阿里 TOP 100</a></li><li class="dropdown-item"><!----> <a href="/algorithm/front-end.html" class="nav-link">前端手写代码</a></li><li class="dropdown-item"><!----> <a href="/algorithm/class.html" class="nav-link">跟着Carl学算法</a></li><li class="dropdown-item"><!----> <a href="/algorithm/tencent.html" class="nav-link">腾讯精选练习 50 题</a></li><li class="dropdown-item"><!----> <a href="/algorithm/2020.html" class="nav-link">2020 名企高频面试题</a></li><li class="dropdown-item"><!----> <a href="/algorithm/middle.html" class="nav-link">中级算法</a></li></ul></div></div><div class="nav-item"><a href="http://blog.alanwu.website/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  旧版博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Webpack</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/webpack/#_1、模块热更新" class="sidebar-link">1、模块热更新</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_2、webpack中hash、chunkhash、contenthash" class="sidebar-link">2、webpack中hash、chunkhash、contenthash</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_3、loader" class="sidebar-link">3、Loader</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_4、plugin" class="sidebar-link">4、Plugin</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_5、tree-shaking" class="sidebar-link">5、Tree-shaking</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_6、file-loader-url-loader-html-loader" class="sidebar-link">6、file-loader &amp; url-loader &amp; html-loader</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_7、extracttextplugin-mini-css-extract-plugin" class="sidebar-link">7、ExtractTextPlugin &amp; mini-css-extract-plugin</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_8、webpack与grunt、gulp的不同" class="sidebar-link">8、webpack与grunt、gulp的不同</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_9、与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？" class="sidebar-link">9、与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_10、有哪些常见的loader？他们是解决什么问题的？" class="sidebar-link">10、有哪些常见的Loader？他们是解决什么问题的？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_11、有哪些常见的plugin？他们是解决什么问题的？" class="sidebar-link">11、有哪些常见的Plugin？他们是解决什么问题的？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_12、loader和plugin的不同？" class="sidebar-link">12、Loader和Plugin的不同？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_13、webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全" class="sidebar-link">13、webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_14、是否写过loader和plugin？描述一下编写loader或plugin的思路？" class="sidebar-link">14、是否写过Loader和Plugin？描述一下编写loader或plugin的思路？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_15、webpack的热更新是如何做到的？说明其原理？" class="sidebar-link">15、webpack的热更新是如何做到的？说明其原理？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_16、如何利用webpack来优化前端性能？（提高性能和体验）" class="sidebar-link">16、如何利用webpack来优化前端性能？（提高性能和体验）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_17、如何提高webpack的构建速度？" class="sidebar-link">17、如何提高webpack的构建速度？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_18、怎么配置单页应用？怎么配置多页应用？" class="sidebar-link">18、怎么配置单页应用？怎么配置多页应用？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_19、如何在vue项目中实现按需加载" class="sidebar-link">19、如何在vue项目中实现按需加载</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_20、webpack的基本功能和工作原理" class="sidebar-link">20、webpack的基本功能和工作原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_21、什么是长缓存？在webpack中如何做到长缓存优化？" class="sidebar-link">21、什么是长缓存？在webpack中如何做到长缓存优化？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/webpack/#_22、webpack底层原理" class="sidebar-link">22、webpack底层原理</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="_1、模块热更新"><a href="#_1、模块热更新" class="header-anchor">#</a> 1、模块热更新</h2> <p><img src="https://static.vue-js.com/adc05780-acd4-11eb-ab90-d9ae814b240d.png" alt="img"></p> <ul><li>Webpack Compile：将 JS 源代码编译成 bundle.js</li> <li>HMR Server：用来将热更新的文件输出给 HMR Runtime</li> <li>Bundle Server：静态资源文件服务器，提供文件访问路径</li> <li>HMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化</li> <li>bundle.js：构建输出的文件</li> <li>在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化</li></ul> <p>上面图中，可以分成两个阶段：</p> <ul><li>启动阶段为上图 1 - 2 - A - B</li></ul> <p>在编写未经过<code>webpack</code>打包的源代码后，<code>Webpack Compile</code> 将源代码和 <code>HMR Runtime</code> 一起编译成 <code>bundle</code>文件，传输给<code>Bundle Server</code> 静态资源服务器</p> <ul><li>更新阶段为上图 1 - 2 - 3 - 4</li></ul> <p>当某一个文件或者模块发生变化时，<code>webpack</code>监听到文件变化对文件重新编译打包，编译生成唯一的<code>hash</code>值，这个<code>hash</code>值用来作为下一次热更新的标识</p> <p>根据变化的内容生成两个补丁文件：<code>manifest</code>（包含了 <code>hash</code> 和 <code>chundId</code>，用来说明变化的内容）和<code>chunk.js</code> 模块</p> <p>由于<code>socket</code>服务器在<code>HMR Runtime</code> 和 <code>HMR Server</code>之间建立 <code>websocket</code>链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的<code>hash</code>值，如下图的<code>h</code>属性，作为下一次热更细的标识</p> <p><img src="https://static.vue-js.com/05a0edf0-ad4a-11eb-85f6-6fac77c0c9b3.png" alt="img"></p> <p>在浏览器接受到这条消息之前，浏览器已经在上一次<code>socket</code> 消息中已经记住了此时的<code>hash</code> 标识，这时候我们会创建一个 <code>ajax</code> 去服务端请求获取到变化内容的 <code>manifest</code> 文件</p> <p><code>mainfest</code>文件包含重新<code>build</code>生成的<code>hash</code>值，以及变化的模块，对应上图的<code>c</code>属性</p> <p>浏览器根据 <code>manifest</code> 文件获取模块变化的内容，从而触发<code>render</code>流程，实现局部模块更新</p> <p><img src="https://static.vue-js.com/0e7b7850-ad4a-11eb-ab90-d9ae814b240d.png" alt="img"></p> <p>总结：</p> <ul><li>通过<code>webpack-dev-server</code>创建两个服务器：提供静态资源的服务（express）和Socket服务</li> <li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li> <li>socket server 是一个 websocket 的长连接，双方可以通信</li> <li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li> <li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li> <li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</li></ul> <h2 id="_2、webpack中hash、chunkhash、contenthash"><a href="#_2、webpack中hash、chunkhash、contenthash" class="header-anchor">#</a> 2、webpack中hash、chunkhash、contenthash</h2> <p>（1）hash</p> <ul><li>hash是工程级别的，修改的每一个文件，文件名的哈希值都会改变，缓存会失效</li> <li>但是对于没有改变的模块而言显然是不合理的，chunkhash就是为了解决这个问题而来</li></ul> <p><img src="https://img2018.cnblogs.com/blog/887360/201809/887360-20180904134123992-581664738.png" alt="img"></p> <p>（2）chunkhash</p> <ul><li>chunkhash会根据不同的入口文件进行依赖文件解析，构建对应的chunk，生成对应的哈希值</li> <li>公共库和程序入口文件区分开，单独打包构建。只要不改变公共库里面的东西，chunkhash就不会改变</li> <li>但是样式作为模块import到JavaScript文件中的，所以它们的chunkhash是一致的，如test1.js和test1.css</li> <li>只要对应css或则js改变，与其关联的文件hash值也会改变，但其内容并没有改变呢，所以没有达到缓存意义</li></ul> <p><img src="https://img2018.cnblogs.com/blog/887360/201809/887360-20180904140438870-871123820.png" alt="img"></p> <p>（3）contenthash</p> <ul><li>针对文件内容级别的，只有你自己模块的内容变了，那么hash值才改变</li></ul> <p><img src="https://img2018.cnblogs.com/blog/887360/201809/887360-20180904141159855-1073612332.png" alt="img"></p> <p>总结：</p> <ul><li>hash：每次构建会生成一个hash。和整个项目有关，只要有项目文件更改，就会改变hash</li> <li>contenthash：和单个文件的内容相关。指定文件的内容发生改变，就会改变hash</li> <li>chunkhash：和webpack打包生成的chunk相关。每一个entry，都会有不同的hash</li></ul> <p>使用场景：</p> <p>（1）chunkhash用法</p> <p>一般来说，针对于输出文件，我们使用chunkhash。因为webpack打包后，最终每个entry文件及其依赖会生成单独的一个js文件。</p> <p>此时使用chunkhash，能够保证整个打包内容的更新准确性。</p> <p>（2）contenthash用法</p> <p>对于css文件来说，一般会使用MiniCssExtractPlugin将其抽取为一个单独的css文件。此时可以使用contenthash进行标记，确保css文件内容变化时，可以更新hash。</p> <p>（3）hash用法</p> <p>一般来说，没有什么机会直接使用hash。hash会更据每次工程的内容进行计算，很容易造成不必要的hash变更，不利于版本管理。</p> <h2 id="_3、loader"><a href="#_3、loader" class="header-anchor">#</a> 3、Loader</h2> <p><strong>loader其实就是一个翻译员，通过输入源文件然后输出处理之后的文件</strong></p> <p>比如scss源代码，webpack会先将源代码给scss-loader，然后给css-loader，然后给style-loader。顺序是又后往前。loader的职责是单一的，每次只完成一种转换，一个文件需要多个loader处理时，会链式顺序执行，下一个loader会接受上一个loader处理过后的结果继续处理。</p> <p>webpack是运行在node之上的，每个loader其实就是一个模块。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">source</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 处理...</span>
  <span class="token keyword">return</span> source<span class="token punctuation">;</span>
<span class="token punctuation">}</span>           
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>获取loader的options：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> loaderUtils <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'loader-utils'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
module<span class="token punctuation">.</span><span class="token function-variable function">export</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">source</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    
  <span class="token keyword">const</span> options <span class="token operator">=</span> loaderUtils<span class="token punctuation">.</span><span class="token function">getOptions</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
  <span class="token keyword">return</span> source<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>              
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>loader返回其他结果：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">export</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">souce</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>source<span class="token punctuation">,</span>sourceMap<span class="token punctuation">)</span><span class="token punctuation">;</span>    
  <span class="token keyword">return</span> 
<span class="token punctuation">}</span> 
<span class="token comment">// this,callback是webpack给loader注入的API，方便wenpack和loader的通信   </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>loader处理二进制数据：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">source</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 如果是二进制数据，source就是Buffer类型的</span>
    source <span class="token keyword">instanceof</span> <span class="token class-name">Buffer</span> <span class="token operator">===</span> <span class="token boolean">true</span>
    <span class="token keyword">return</span> source
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>raw <span class="token operator">=</span> <span class="token boolean">true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>loader默认开启缓存加速：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">source</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 关闭缓存</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cacheable</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> source
<span class="token punctuation">}</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>加载本地loader：</p> <p>如果是开发本地loader放在node_modules目录里面会很不方便，有两种办法可以解决：</p> <p>1、npm link</p> <p>它是一种专门开发和调试本地模块的方法，把一个正在开发的本地模块通过软连接的方式连接到node_modules上面。</p> <p>步骤：</p> <p>1、你的loader在package.json中配置好</p> <p>2、在本地npm目录执行npm link，注册到全局</p> <p>3、在项目根目录执行npm link loader-name，注册本地的loader到node_modules中</p> <p>实现一个loader：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">replaceMyContent</span><span class="token punctuation">(</span><span class="token parameter">source</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> source<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\/\/ *@require) +(('|&quot;).+('|&quot;)).*</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token string">'require($2);'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">content</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">replaceMyContent</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_4、plugin"><a href="#_4、plugin" class="header-anchor">#</a> 4、Plugin</h2> <p>plugin机制使得webpack更加的灵活，webpack在运行的过程中会广播出很多事件，plugin的作用就是监听这些事件，然后执行相应的处理函数。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">BasicPlugin</span><span class="token punctuation">{</span>
    <span class="token comment">// 构造函数</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            
    <span class="token punctuation">}</span>
    <span class="token comment">// webpack会调用BasicPlugin的apply方法，传入compiler对象</span>
    <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'compilation'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">compilation</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    
        <span class="token punctuation">}</span><span class="token punctuation">)</span>    
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> BasicPlugin
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>​</p> <p>工作原理：</p> <ul><li><p>webpack启动之后会执行BasicPlugin的构造函数，获得实例</p></li> <li><p>初始化compiler对象之后，调用basicPlugin对象的apply方法，传入compiler对象</p></li> <li><p>实例获取compiler对象之后就可以通过compiler.plugin方法监听webpack广播的事件了</p></li></ul> <p><strong>compiler</strong>和<strong>compilation</strong>的区别：</p> <p>1、compiler是包含了webpack环境的所有信息，可以理解为一个<strong>webpack实例，全局唯一</strong></p> <p>2、compilation对象包含了当前模块资源，编译生成的资源，变化的文件等。每当检查到文件发生变化，一次新的compilation对象将被创建。</p> <p>小结：</p> <p>compiler包含整个webpack启动到关闭的生命周期，而compilation只是包含一次编译</p> <p>webpack的emit事件发生时，代表资源的输出已经准备好了；在这里可以读取最终输出的资源，代码块以及其中的依赖。并且可以修改其输出的内容。</p> <p>实现一个plugin：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 在webpack退出之前执行</span>
<span class="token keyword">class</span> <span class="token class-name">EndWebpackPlugin</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">donecallback<span class="token punctuation">,</span>failcallback</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>donecallback <span class="token operator">=</span> donecallback<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>failcallback <span class="token operator">=</span> failcallback<span class="token punctuation">;</span>    
    <span class="token punctuation">}</span>
    
    <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'done'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">stats</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">donecallback</span><span class="token punctuation">(</span>stats<span class="token punctuation">)</span>        
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'fail'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">failcallback</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        
        <span class="token punctuation">}</span><span class="token punctuation">)</span>          
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> EndWebpackPlugin
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="_5、tree-shaking"><a href="#_5、tree-shaking" class="header-anchor">#</a> 5、Tree-shaking</h2> <p>Tree Shaking 可以用来剔除 JavaScript 中用不上的死代码。它依赖静态的 ES6 模块化语法，例如通过 <code>import</code> 和 <code>export</code> 导入导出。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// util.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">funcA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">funB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>funcA<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./util.js'</span><span class="token punctuation">;</span>
<span class="token function">funcA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// Tree Shaking 后的util.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">funcA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Tree Shaking 正常工作的前提是交给 Webpack 的 JavaScript 代码必须是采用<strong>ES6 模块化</strong>语法的， 因为 ES6 模块化语法是静态的（导入导出语句中的路径必须是静态的字符串，而且不能放入其它代码块中），这让 Webpack 可以简单的分析出哪些 <code>export</code> 的被 <code>import</code> 过了。</p> <p>原理：作用域分析，就是可以分析出代码里面变量所属的作用域以及他们之间的引用关系。有了这些信息，就可以推导出<strong>导出变量</strong>和<strong>导入变量</strong>之间的引用关系。</p> <div class="tip custom-block"><p class="custom-block-title">目前的 Tree Shaking 还有些的局限性，经实验发现</p> <ol><li>不会对entry入口文件做 Tree Shaking。</li> <li>不会对异步分割出去的代码做 Tree Shaking。</li></ol></div> <h2 id="_6、file-loader-url-loader-html-loader"><a href="#_6、file-loader-url-loader-html-loader" class="header-anchor">#</a> 6、file-loader &amp; url-loader &amp; html-loader</h2> <p>（1）file-loader 可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名以获得更好的缓存。此外，这意味着 你可以就近管理图片文件，可以使用相对路径而不用担心部署时 URL 的问题。使用正确的配置，webpack 将会在打包输出中自动重写文件路径为正确的 URL。</p> <p>（2）url-loader 允许你有条件地将文件转换为内联的 base-64 URL (当文件小于给定的阈值)，这会减少小文件的 HTTP 请求数。如果文件大于该阈值，会自动的交给 file-loader 处理。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>module：<span class="token punctuation">{</span>
    rules：<span class="token punctuation">[</span>
        <span class="token punctuation">{</span> test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(jpg|png|gif|bmp|jpeg)$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">,</span><span class="token comment">//正则表达式匹配图片规则，i忽略大小写</span>
        use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
        loader<span class="token operator">:</span><span class="token string">'url-loader'</span><span class="token punctuation">,</span>
        options<span class="token operator">:</span><span class="token punctuation">{</span>
            limit<span class="token operator">:</span><span class="token number">8192</span><span class="token punctuation">,</span><span class="token comment">//限制打包图片的大小：</span>
            <span class="token comment">//如果大于或等于8192Byte，则按照相应的文件名和路径打包图片；如果小于8192Byte，则将图片转成base64格式的字符串。</span>
            name<span class="token operator">:</span><span class="token string">'img/[name].[hash:8].[ext]'</span><span class="token punctuation">,</span><span class="token comment">//img:图片打包的文件夹；</span>
            <span class="token comment">//[name].[ext]：设定图片按照本来的文件名和扩展名打包，不用进行额外编码</span>
            <span class="token comment">//[hash:8]：一个项目中如果两个文件夹中的图片重名，打包图片就会被覆盖，加上hash值的前八位作为图片名，可以避免重名。</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>（3）html-loader可以让你直接在html文件里直接引入这个文件，而不是通过js的方式引入，但是你需要使用file-loader/url-loader来解析你的文件</p> <h2 id="_7、extracttextplugin-mini-css-extract-plugin"><a href="#_7、extracttextplugin-mini-css-extract-plugin" class="header-anchor">#</a> 7、ExtractTextPlugin &amp; mini-css-extract-plugin</h2> <p>（1）ExtractTextPlugin</p> <p>extract-text-webpack-plugin该插件的主要是为了抽离css样式,防止将样式打包在js中引起页面样式加载错乱的现象。假如不使用，webpack打包后的css文件会打包到js中，如果引用了改js文件，css会以style的形式被插到了head中。使用之后，bundle.js文件恢复了正常，并多出来一个style.css文件。如果配合HtmlWebpackPlugin插件则自动插入index.html中。</p> <p>（2）mini-css-extract-plugin</p> <p>将CSS提取为独立的文件的插件，对每个包含css的js文件都会创建一个CSS文件，支持按需加载css和sourceMap。</p> <p>总结：</p> <p>只能用在webpack4中，对比另一个插件 extract-text-webpack-plugin优点:</p> <ul><li>异步加载</li> <li>不重复编译，性能更好</li> <li>更容易使用</li> <li>只针对CSS</li></ul> <p>目前缺失功能，HMR。</p> <h2 id="_8、webpack与grunt、gulp的不同"><a href="#_8、webpack与grunt、gulp的不同" class="header-anchor">#</a> 8、webpack与grunt、gulp的不同</h2> <p>三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。</p> <p>grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。</p> <p>webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能</p> <p><code>从构建思路来说</code></p> <p>gulp和grunt需要开发者将整个前端构建过程拆分成多个<code>Task</code>，并合理控制所有<code>Task</code>的调用关系
webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工</p> <p><code>知识背景来说</code></p> <p>gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路</p> <h2 id="_9、与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？"><a href="#_9、与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？" class="header-anchor">#</a> 9、与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？</h2> <p>同样是基于入口的打包工具还有以下几个主流的：</p> <ul><li>webpack</li> <li>rollup</li> <li>parcel</li></ul> <p><code>应用场景</code></p> <ul><li>webpack适用于大型复杂的前端站点构建</li> <li>rollup适用于基础库的打包，如vue、react</li> <li>parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果</li></ul> <h2 id="_10、有哪些常见的loader？他们是解决什么问题的？"><a href="#_10、有哪些常见的loader？他们是解决什么问题的？" class="header-anchor">#</a> 10、有哪些常见的Loader？他们是解决什么问题的？</h2> <ul><li><p>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</p></li> <li><p>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</p></li> <li><p>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</p></li> <li><p>image-loader：加载并且压缩图片文件</p></li> <li><p>babel-loader：把 ES6 转换成 ES5</p></li> <li><p>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</p></li> <li><p>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</p></li> <li><p>eslint-loader：通过 ESLint 检查 JavaScript 代码</p></li></ul> <h2 id="_11、有哪些常见的plugin？他们是解决什么问题的？"><a href="#_11、有哪些常见的plugin？他们是解决什么问题的？" class="header-anchor">#</a> 11、有哪些常见的Plugin？他们是解决什么问题的？</h2> <ul><li><p>define-plugin：定义环境变量</p></li> <li><p>commons-chunk-plugin：提取公共代码</p></li> <li><p>uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</p></li></ul> <h2 id="_12、loader和plugin的不同？"><a href="#_12、loader和plugin的不同？" class="header-anchor">#</a> 12、Loader和Plugin的不同？</h2> <p><code>不同的作用</code></p> <p>Loader直译为&quot;加载器&quot;。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</p> <p>Plugin直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p> <p><code>不同的用法</code></p> <p>Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</p> <p>Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</p> <h2 id="_13、webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全"><a href="#_13、webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全" class="header-anchor">#</a> 13、webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全</h2> <p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p> <ul><li><p><code>初始化参数</code>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</p></li> <li><p><code>开始编译</code>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</p></li> <li><p><code>确定入口</code>：根据配置中的 entry 找出所有的入口文件；</p></li> <li><p><code>编译模块</code>：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</p></li> <li><p><code>完成模块编译</code>：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</p></li> <li><p><code>输出资源</code>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</p></li> <li><p><code>输出完成</code>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p></li></ul> <p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p> <h2 id="_14、是否写过loader和plugin？描述一下编写loader或plugin的思路？"><a href="#_14、是否写过loader和plugin？描述一下编写loader或plugin的思路？" class="header-anchor">#</a> 14、是否写过Loader和Plugin？描述一下编写loader或plugin的思路？</h2> <p>Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。</p> <p>编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。</p> <p>相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果</p> <h2 id="_15、webpack的热更新是如何做到的？说明其原理？"><a href="#_15、webpack的热更新是如何做到的？说明其原理？" class="header-anchor">#</a> 15、webpack的热更新是如何做到的？说明其原理？</h2> <p>webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p> <p><img src="/images/webpack/hmr.jpg" alt></p> <h2 id="_16、如何利用webpack来优化前端性能？（提高性能和体验）"><a href="#_16、如何利用webpack来优化前端性能？（提高性能和体验）" class="header-anchor">#</a> 16、如何利用webpack来优化前端性能？（提高性能和体验）</h2> <p>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。</p> <p>压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css</p> <p>利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径</p> <p>删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现
提取公共代码</p> <h2 id="_17、如何提高webpack的构建速度？"><a href="#_17、如何提高webpack的构建速度？" class="header-anchor">#</a> 17、如何提高webpack的构建速度？</h2> <p>多入口情况下，使用CommonsChunkPlugin来提取公共代码</p> <ul><li><p>通过externals配置来提取常用库</p></li> <li><p>利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。</p></li> <li><p>使用Happypack 实现多线程加速编译</p></li> <li><p>使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</p></li> <li><p>使用Tree-shaking和Scope Hoisting来剔除多余代码</p></li></ul> <h2 id="_18、怎么配置单页应用？怎么配置多页应用？"><a href="#_18、怎么配置单页应用？怎么配置多页应用？" class="header-anchor">#</a> 18、怎么配置单页应用？怎么配置多页应用？</h2> <p>单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述</p> <p>多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是：</p> <ul><li><p>每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表</p></li> <li><p>随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置</p></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>module<span class="token punctuation">.</span>entrys <span class="token operator">=</span> <span class="token punctuation">{</span>
    entry<span class="token operator">:</span> <span class="token punctuation">{</span>
        pageOne<span class="token operator">:</span> <span class="token string">'./src/pageOne/index.js'</span><span class="token punctuation">,</span>
        pageTwo<span class="token operator">:</span> <span class="token string">'./src/pageTwo/index.js'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>module<span class="token punctuation">.</span>entrys <span class="token operator">=</span> <span class="token punctuation">{</span>
    entry<span class="token operator">:</span> <span class="token punctuation">{</span>
        pageOne<span class="token operator">:</span> <span class="token string">'./src/pageOne/index.js'</span><span class="token punctuation">,</span>
        pageTwo<span class="token operator">:</span> <span class="token string">'./src/pageTwo/index.js'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_19、如何在vue项目中实现按需加载"><a href="#_19、如何在vue项目中实现按需加载" class="header-anchor">#</a> 19、如何在vue项目中实现按需加载</h2> <p>Vue UI组件库的按需加载 为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。</p> <p>不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了</p> <div class="language-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;presets&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&quot;es2015&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token property">&quot;modules&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">&quot;plugins&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">[</span>
      <span class="token string">&quot;component&quot;</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        <span class="token property">&quot;libraryName&quot;</span><span class="token operator">:</span> <span class="token string">&quot;element-ui&quot;</span><span class="token punctuation">,</span>
        <span class="token property">&quot;styleLibraryName&quot;</span><span class="token operator">:</span> <span class="token string">&quot;theme-chalk&quot;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。</p> <p>通过import(<em>)语句来控制加载时机，webpack内置了对于import(</em>)的解析，会将import(<em>)中引入的模块作为一个新的入口在生成一个chunk。 当代码执行到import(</em>)语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill</p> <h2 id="_20、webpack的基本功能和工作原理"><a href="#_20、webpack的基本功能和工作原理" class="header-anchor">#</a> 20、webpack的基本功能和工作原理</h2> <ul><li><p>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等</p></li> <li><p>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等</p></li> <li><p>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载</p></li> <li><p>模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件</p></li> <li><p>自动刷新：监听本地源代码的变化，自动构建，刷新浏览器</p></li> <li><p>代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过</p></li> <li><p>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统</p></li></ul> <h2 id="_21、什么是长缓存？在webpack中如何做到长缓存优化？"><a href="#_21、什么是长缓存？在webpack中如何做到长缓存优化？" class="header-anchor">#</a> 21、什么是长缓存？在webpack中如何做到长缓存优化？</h2> <ul><li><p>浏览器在用户访问页面的时候，为了加快加载速度会对用户访问的静态资源进行存储，但是每一次代码升级或更新都需要浏览器下载新的代码，最简单方便的方式就是引入新的文件名称。</p></li> <li><p>webpack中可以在output中指定chunkhash，并且分离经常更新的代码和框架代码。通过NameModulesPlugin或HashedModuleIdsPlugin使再次打包文件名不变</p></li></ul> <h2 id="_22、webpack底层原理"><a href="#_22、webpack底层原理" class="header-anchor">#</a> 22、webpack底层原理</h2> <p><code>步骤</code></p> <ul><li><p>拿到入口文件的代码并读出来转化为js对象(抽象语法术parser)</p></li> <li><p>拿到所有模块的依赖 ‘./message.js’,放进数组中 引入第三方模块和babel相关</p></li> <li><p>对代码进行转换使浏览器能够执行从es6/es module语法转化</p></li> <li><p>创建打包函数Complier</p></li> <li><p>传入入口文件,引入fs模块,使用fs.readFileSync读取入口文件,格式为utf-8</p></li> <li><p>使用parser.parse分析出抽象语法术</p></li> <li><p>使用traverse进行模块分析获取内容,获取依赖路径,把require替换成__webpack_require__;准备一个依赖数组,将获取的路径存储进去</p></li> <li><p>递归遍历依赖数组,将每个路径文件都解析</p></li> <li><p>打包文件,输出打包路径和结果</p></li></ul></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.6c60143e.js" defer></script><script src="/assets/js/68.0d2e42a1.js" defer></script>
  </body>
</html>
